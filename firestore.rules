rules_version = '2';
service cloud.firestore {
	match /databases/{database}/documents {
		// Shared helpers keep role/identity checks consistent across collections.
		function signedIn() {
			return request.auth != null;
		}

		function uid() {
			return request.auth.uid;
		}

		function isAdmin() {
			return signedIn() && request.auth.token.admin == true;
		}

		function emailMatches(value) {
			return signedIn() && request.auth.token.email != null && value == request.auth.token.email;
		}

		function phoneMatches(value) {
			return signedIn() && request.auth.token.phone_number != null && value == request.auth.token.phone_number;
		}

		function isMerchantData(data) {
			return signedIn() && data.merchantId == uid();
		}

		function isMerchantRequest(data) {
			return signedIn() && data.merchantId == uid();
		}

		function isBrandData(data) {
			return signedIn() && data.brandId == uid();
		}

		function isStoreOwner(data) {
			return signedIn() && data.storeId == uid();
		}

		function isRoomParticipant(data) {
			return isMerchantData(data) ||
						 (data.customerId != null && data.customerId == uid()) ||
						 (data.members != null && uid() in data.members);
		}

		function isCommunityMember(data) {
			return isMerchantData(data) || (data.members != null && uid() in data.members);
		}

		function hasCommunityLinkToMerchant(merchantId) {
			return signedIn() && merchantId != null &&
					exists(/databases/$(database)/documents/merchantCustomerRooms/$(merchantId + '_' + uid()));
		}

		function hasMerchantCustomerLink(merchantId, customerId) {
			return signedIn() && merchantId != null && customerId != null &&
				exists(/databases/$(database)/documents/merchantCustomerRooms/$(merchantId + '_' + customerId));
		}

		function merchantHasCustomerLink(customerId) {
			return signedIn() && hasMerchantCustomerLink(uid(), customerId);
		}



		function loyaltyFieldsOnlyChanged() {
			return request.resource != null && resource.data != null &&
				request.resource.data.diff(resource.data).affectedKeys().hasOnly(
					['totalPoints', 'merchantPoints', 'brandPoints']
				);
		}

		function merchantPointsUpdateAllowed(customerId) {
			return merchantHasCustomerLink(customerId) && loyaltyFieldsOnlyChanged();
		}

		function isRewardOwner(data) {
			return (data.userId != null && data.userId == uid()) ||
						 (data.userEmail != null && emailMatches(data.userEmail)) ||
						 (data.userPhone != null && (phoneMatches(data.userPhone) || emailMatches(data.userPhone)));
		}

		// Customer identity documents keyed by Firebase Auth UID.
		match /users/{userId} {
			allow read: if signedIn() && userId == uid();
			allow create: if signedIn() && (
				userId == uid() ||
				(request.resource.data.email != null && emailMatches(request.resource.data.email))
			);
			allow update: if signedIn() && userId == uid();
			allow delete: if false;
		}

		// Merchant profile + settings, keyed by merchant auth UID.
		match /merchants/{merchantId} {
			allow read: if signedIn();
			allow create: if signedIn() && merchantId == uid();
			allow update: if signedIn() && merchantId == uid();
			allow delete: if false;
		}

		// Brand profile (admin portal) + nested content managed by the brand owner.
		match /brands/{brandId} {
			allow read: if signedIn() && (brandId == uid() || isAdmin());
			allow create: if signedIn() && brandId == uid();
			allow update: if signedIn() && brandId == uid();
			allow delete: if false;

			match /products/{productId} {
				allow read, create, update, delete: if signedIn() && brandId == uid();
			}

			match /rewards/{rewardId} {
				allow read, create, update, delete: if signedIn() && brandId == uid();
			}

			match /campaigns/{campaignId} {
				allow read, create, update, delete: if signedIn() && brandId == uid();
			}

			match /communityPosts/{postId} {
				allow read, create, update, delete: if signedIn() && brandId == uid();
			}
		}

		match /merchantCodes/{code} {
			allow get: if signedIn();
			allow list: if isAdmin();
			allow create: if signedIn() && request.resource.data.merchantId == uid();
			allow update: if signedIn() && resource.data.merchantId == uid();
			allow delete: if false;
		}

		// Promotional offers surfaced to the customer app.
		match /offers/{offerId} {
			function isOfferOwner(data) {
				return (
					(data.ownerType == 'merchant' && data.merchantId == uid()) ||
					(data.ownerType == 'customer' && data.customerId == uid()) ||
					(data.ownerType == null && data.merchantId == uid())
				);
			}

			allow read: if signedIn();
			allow create: if signedIn() && (
				(request.resource.data.ownerType == 'merchant' && request.resource.data.merchantId == uid()) ||
				(request.resource.data.ownerType == 'customer' && request.resource.data.customerId == uid())
			);
			allow update, delete: if signedIn() && isOfferOwner(resource.data);
		}

		// Merchant product catalog entries (not publicly readable yet).
		match /products/{productId} {
			allow read, update, delete: if signedIn() && resource.data.merchantId == uid();
			allow create: if signedIn() && request.resource.data.merchantId == uid();
		}

		// Loyalty rewards that customers browse + merchants manage.
		match /rewards/{rewardId} {
			allow read: if signedIn();
			allow create: if signedIn() && request.resource.data.merchantId == uid();
			allow update, delete: if signedIn() && resource.data.merchantId == uid();
		}

		// Targeted in-app notifications (read + dismiss by owner only).
		match /notifications/{notificationId} {
			allow read: if signedIn() && resource.data.userId == uid();
			allow update: if signedIn() && resource.data.userId == uid();
			allow create: if signedIn() && request.resource.data.createdBy == uid();
			allow delete: if isAdmin();
		}

		// Aggregated customer points ledger keyed by customer auth UID.
		match /customers/{customerId} {
			allow read: if signedIn() && (
				customerId == uid() ||
				(resource.data.merchantPoints != null && resource.data.merchantPoints[uid()] != null) ||
				merchantHasCustomerLink(customerId)
			);
			allow create: if signedIn() && customerId == uid();
			allow update: if signedIn() && (
				customerId == uid() ||
				merchantPointsUpdateAllowed(customerId)
			);
			allow delete: if false;

			match /pointsHistory/{entryId} {
				allow read: if signedIn() && customerId == uid();
				allow create: if signedIn() && (
					customerId == uid() ||
					(merchantHasCustomerLink(customerId) && request.resource.data.merchantId == uid())
				);
				allow update, delete: if false;
			}
		}

		// Merchant-managed cashier/staff records.
		match /cashiers/{cashierId} {
			allow read, update, delete: if signedIn() && resource.data.merchantId == uid();
			allow create: if signedIn() && request.resource.data.merchantId == uid();
		}

		// Invoices created from OCR scans â€“ readable by both sides.
		match /invoices/{invoiceId} {
			allow read: if signedIn() && (resource.data.customerId == uid() || resource.data.merchantId == uid());
			allow create: if signedIn() && request.resource.data.customerId == uid();
			allow update: if signedIn() && resource.data.merchantId == uid();
			allow delete: if false;
		}

		// Lightweight log that links OCR payloads to invoices for tracing.
		match /invoiceLinks/{linkId} {
			allow read: if signedIn() && (resource.data.customerId == uid() || resource.data.merchantId == uid());
			allow create: if signedIn() && request.resource.data.customerId == uid();
			allow update, delete: if false;
		}

		// Conversation room metadata between a merchant and a customer.
		match /merchantCustomerRooms/{roomId} {
			allow read: if signedIn() && (resource == null || isRoomParticipant(resource.data));
			allow create: if signedIn() && isRoomParticipant(request.resource.data);
			allow update: if signedIn() && isRoomParticipant(resource.data) && isRoomParticipant(request.resource.data);
			allow delete: if false;

			match /messages/{messageId} {
				function canAccessMerchantRoomMessage() {
					return signedIn() && exists(/databases/$(database)/documents/merchantCustomerRooms/$(roomId)) &&
						isRoomParticipant(get(/databases/$(database)/documents/merchantCustomerRooms/$(roomId)).data);
				}

				allow read: if canAccessMerchantRoomMessage();
				allow create: if canAccessMerchantRoomMessage() && request.resource.data.senderId == uid();
				allow update: if canAccessMerchantRoomMessage() && request.resource.data.keys().hasOnly(['reactions', 'senderId', 'body', 'createdAt']) &&
					resource.data.senderId == request.resource.data.senderId &&
					resource.data.body == request.resource.data.body &&
					resource.data.createdAt == request.resource.data.createdAt;
				allow delete: if false;
			}
		}

		// Merchant-hosted community rooms and their message threads.
		match /communities/{communityId} {
			allow read: if signedIn() && (isCommunityMember(resource.data) || hasCommunityLinkToMerchant(resource.data.merchantId));
			allow create: if signedIn() && isMerchantRequest(request.resource.data);
			allow update, delete: if signedIn() && resource.data.merchantId == uid() && request.resource.data.merchantId == resource.data.merchantId;

			match /messages/{messageId} {
				function canAccessCommunityMessage() {
					return signedIn() && (
						isCommunityMember(get(/databases/$(database)/documents/communities/$(communityId)).data) ||
						hasCommunityLinkToMerchant(get(/databases/$(database)/documents/communities/$(communityId)).data.merchantId)
					);
				}

				function hasPrivateRecipients(docData) {
					return docData.privateRecipients != null && docData.privateRecipients.size() > 0;
				}

				function canSeePrivateCommunityMessage(docData) {
					return !hasPrivateRecipients(docData) ||
						docData.senderId == uid() ||
						docData.privateRecipients.hasAny([uid()]);
				}

				allow list: if canAccessCommunityMessage();
				allow get: if canAccessCommunityMessage() && canSeePrivateCommunityMessage(resource.data);
				allow create: if canAccessCommunityMessage() && request.resource.data.senderId == uid() &&
					(!hasPrivateRecipients(request.resource.data) || request.resource.data.privateRecipients.hasAny([uid()]));
				allow update: if canAccessCommunityMessage() && canSeePrivateCommunityMessage(resource.data) && request.resource.data.keys().hasOnly(['reactions', 'senderId', 'body', 'createdAt', 'parentMessageId', 'privateRecipients']) &&
					resource.data.senderId == request.resource.data.senderId &&
					resource.data.body == request.resource.data.body &&
					resource.data.createdAt == request.resource.data.createdAt &&
					resource.data.parentMessageId == request.resource.data.parentMessageId &&
					resource.data.privateRecipients == request.resource.data.privateRecipients;
				allow delete: if false;
			}
		}

		// Public community groups surfaced in the consumer app.
		match /groups/{groupId} {
			allow get, list: if signedIn();
			allow create, update, delete: if isAdmin();

			match /messages/{messageId} {
				allow get, list: if signedIn();
				allow create, update, delete: if isAdmin();
			}
		}

		// Snapshot of rewards that belong to a specific user/contact.
		match /user_rewards/{userRewardId} {
			allow read: if signedIn() && isRewardOwner(resource.data);
			allow create, update, delete: if isAdmin();
		}

		// Customer activity feed, filtered by the signed-in email.
		match /activity_logs/{logId} {
			allow read: if signedIn() && (emailMatches(resource.data.customerEmail) || isAdmin());
			allow write: if isAdmin();
		}

		// Customer-submitted issue reports (admins review them later).
		match /reports/{reportId} {
			allow create: if signedIn();
			allow read, update, delete: if isAdmin();
		}

		// Brand analytics snapshots produced by Cloud Functions.
		match /brand_store_performance/{docId} {
			allow read: if signedIn() && (isBrandData(resource.data) || isStoreOwner(resource.data) || isAdmin());
			allow create, update, delete: if isAdmin();
		}

		match /{document=**} {
			allow read, write: if false;
		}
	}
}
